# -*- coding: utf-8 -*-
"""
Created on Mon Jan 6 20:20:16 2020


Input) path to the directory with raw fiber photometry data files generated by Synapse
Output) .pkl file and plots of GCaMP, UV and dFF traces
    

@author: Heeun Jang
"""

#import scipy.io as sio
#from scipy.signal import decimate
#import pandas as pd
import os
#import glob
import numpy as np
import matplotlib.pyplot as plt
import pickle as pk
#import tdt
from tdt import read_block
from scipy import signal

#path           = r"E:\Heeun_New_Photometry_setup3\Photometry_by_date\GUxZK_HJ_setup3-200218_HJ\W1764f22_W1764f00-200217-154736"        
print("Enter the full path for the directory with raw photometry data: ")
path             = input()

Z_stimulus       = "2MNaCl"
K_stimulus       = "2MNaCl"

Z_stim_time      = [21, 4]  ## put the stimulus application/drug injection time as [mm, ss]
K_stim_time      = [21, 21]

Z_pre_post_min   = [10, 40] 
K_pre_post_min   = [10, 40]

Z_F0_window_min  = [0, 10]  ## setting F0 window as a median value of 5-10 mins (equals -5 t0 0 pre-stimulus)
K_F0_window_min  = [0, 10]

ds_factor1       = 5
ds_factor2       = 5
ds_factor3       = 2
ds_factor        = ds_factor1*ds_factor2*ds_factor3

sm_factor        = 61      ## usually 1000 Hz (fps) so this is smoothing over 30000 frames = 30 sec window 

ignore_UV = 0   # If the UV channel shows a change which significantly alters the dFF magnitude, exclude the UV channel

## smoothing 
def smooth (x, window_len, window='hanning'):
        if x.ndim != 1:
                raise ValueError ("smooth only accepts 1 dimension arrays.")
        if x.size < window_len:
                raise ValueError ("Input vector needs to be bigger than window size.")
        if window_len<3:
                return x
        if not window in ['flat', 'hanning', 'hamming', 'bartlett', 'blackman']:
                raise ValueError ("Window is on of 'flat', 'hanning', 'hamming', 'bartlett', 'blackman'")
        s=np.r_[2*x[0]-x[window_len-1::-1],x,2*x[-1]-x[-1:-window_len:-1]]
        if window == 'flat': #moving average
                w=np.ones(window_len,'d')
        else:  
                w=eval('np.'+window+'(window_len)')
        y=np.convolve(w/w.sum(),s,mode='same')
        return y[window_len:-window_len+1]

if Z_stimulus == "chow":
    analysis_path = path + "/analysis_" + str(Z_pre_post_min[1]) + "min"
    
else:
    analysis_path  = path + "/analysis"
if not os.path.exists(analysis_path):
    os.makedirs(analysis_path)

## Read data
data  = read_block(path)
trace = {}
       
blockname = data.info.blockname

## for mouse in Z
mouseZ           = blockname.split('_')[0]
mouseK           = (blockname.split('_')[1]).split('-')[0]

mouse_list       = [mouseZ, mouseK]

for i, mouseID in enumerate (mouse_list):
#    if i == 0:
#         continue
    if mouseID == "none":
        if i == 0:  
            print("No mouse in Z chamber")
        else:
            print("No mouse in K chamber")
        continue
        
    else:
        trace["date"]           = "20" + (blockname.split('_')[1]).split('-')[1]    ## saves as a string 20100408
        trace["time"]           = data.info.utc_start_time  ## saves hh:mm:ss "10:04:10" as a string
        
        if i == 0:
            trace["mouseID"]    = mouseZ 
            trace["stimulus"]   = Z_stimulus
            sampling_rate       = data.streams["G__Z"].fs ## in Hz
            raw_GCaMP           = data.streams["G__Z"].data
            raw_UV              = data.streams["U__Z"].data
            pre_sec             = int(Z_pre_post_min[0])*60
            post_sec            = int(Z_pre_post_min[1])*60
            stim_sec            = int(Z_stim_time[0])*60 + int(Z_stim_time[1]) 

        else:
            trace["mouseID"]    = mouseK
            trace["stimulus"]   = K_stimulus
            sampling_rate       = data.streams["G__K"].fs ## in Hz
            raw_GCaMP           = data.streams["G__K"].data
            raw_UV              = data.streams["U__K"].data
            pre_sec             = int(K_pre_post_min[0])*60
            post_sec            = int(K_pre_post_min[1])*60
            stim_sec            = int(K_stim_time[0])*60 + int(K_stim_time[1])             
            
        ## Crop the trace around the stimulus time
        crop_start_sec   = stim_sec - pre_sec
        crop_end_sec     = stim_sec + post_sec
        
        crop_start_frame = int(np.ceil(crop_start_sec*sampling_rate))
        crop_end_frame   = int(np.floor(crop_end_sec*sampling_rate))
        
        trace["GCaMP"]   = raw_GCaMP[crop_start_frame:crop_end_frame+1]
        trace["UV"]      = raw_UV[crop_start_frame:crop_end_frame+1]
        
        trace["Fratio"]  = trace["GCaMP"]/trace["UV"]
        num_frames       = len(trace["GCaMP"])
        trace["time_sec"] = np.linspace(1, num_frames, num_frames)/sampling_rate
        trace["time_sec"] = trace["time_sec"] - pre_sec
        
        
        ## F0 is the median value from -5 min to 0 pre-injection 
        if i == 0:           
            F0_window_start_frame = int(np.ceil(int(Z_F0_window_min[0])*60*sampling_rate))
            F0_window_end_frame   = int(np.floor(int(Z_F0_window_min[1])*60*sampling_rate))
        else:
            F0_window_start_frame = int(np.ceil(int(K_F0_window_min[0])*60*sampling_rate))
            F0_window_end_frame   = int(np.floor(int(K_F0_window_min[1])*60*sampling_rate))

        F0                   = np.median(trace["Fratio"][F0_window_start_frame:F0_window_end_frame])
       
        trace["dFF"]         = (trace["Fratio"] - F0)/F0*100 
        trace["frame"]       = np.arange(0, len(trace["GCaMP"]), 1)
		
#        trace["dFF_ds"]        = signal.decimate(trace["dFF"], ds_factor)
        temp_trace                = signal.decimate(trace["dFF"], ds_factor1)
        temp_trace                = signal.decimate(temp_trace, ds_factor2)
        trace["dFF_ds"]        = signal.decimate(temp_trace, ds_factor3)
        
        trace["dFF_ds_sm"]     = smooth(trace["dFF_ds"], window_len = sm_factor)
        trace["time_sec_ds"]   = trace["time_sec"][::ds_factor] ## take every 50th element from the list
	    
        trace["dFF_sm_peak"] = np.max(trace["dFF_ds_sm"])
        trace["dFF_sm_scaled"]  = trace["dFF_ds_sm"]/trace["dFF_sm_peak"]
    
        ##  2) plot dFF with all dictionary keys      
        fig, ax = plt.subplots(6, 1, figsize = (8,12))
        ax[0].plot(trace["time_sec"]/60, trace["GCaMP"], color = "green", linewidth = 2, label = "GCaMP")
        ax[0].set_ylim(0.95*min(trace["GCaMP"]), 1.05*max(trace["GCaMP"]))
        ax[0].set_ylabel("raw (a.u.)")
        ax[0].legend(loc='upper right', fontsize = 16)
    #    ax[1] = ax[0].twinx()      
    #    ax[1].plot(trace["time_sec"]/60, trace["UV"], color = "red", linewidth = 2, label = "UV")
    #    ax[1].set_ylim(0.95*min(trace["UV"]), 1.05*max(trace["UV"]))
    #    ax[1].set_ylabel("raw fluorescence (a.u.)")
    #         
        ax[1].plot(trace["time_sec"]/60, trace["UV"], color = "red", linewidth = 2, label = "UV")
        ax[1].set_ylim(0.95*min(trace["UV"]), 1.05*max(trace["UV"]))
        ax[1].set_ylabel("raw (a.u.)")
        ax[1].legend(loc='upper right', fontsize = 16)
        
    #    ax[2] = plt.subplot2grid((1, 1), (1, 0), colspan=8)
        ax[2].plot(trace["time_sec"]/60, trace["Fratio"], color = "black", linewidth = 2, label = "GCaMP/UV")
        ax[2].set_ylim(0.95*min(trace["Fratio"]), 1.05*max(trace["Fratio"]))
        ax[2].set_ylabel("ratio")
        ax[2].legend(loc='upper right', fontsize = 16)
        
        ax[3].plot(trace["time_sec"]/60, trace["dFF"], color = "blue", linewidth = 2, label = "dFF")
        if min(trace["dFF"]) > 0:
            ax[3].set_ylim(0.95*min(trace["dFF"]), 1.05*max(trace["dFF"]))
        else: 
            ax[3].set_ylim(1.05*min(trace["dFF"]), 1.05*max(trace["dFF"]))
        ax[3].set_ylabel("dF/F0 (%)")  
        ax[3].legend(loc='upper right', fontsize = 16)
        
        ax[4].plot(trace["time_sec_ds"]/60, trace["dFF_ds"], color = "purple", linewidth = 2, label = "dFF_ds")
        if min(trace["dFF_ds_sm"]) > 0:
            ax[4].set_ylim(0.95*min(trace["dFF_ds_sm"]), 1.05*max(trace["dFF_ds_sm"]))
        else: 				
            ax[4].set_ylim(1.05*min(trace["dFF_ds_sm"]), 1.05*max(trace["dFF_ds_sm"]))
        ax[4].set_ylabel("dF/F0 (%)") 
        ax[4].set_xlabel("time (min)")
        ax[4].legend(loc='upper right', fontsize = 16)
        
        ax[5].plot(trace["time_sec_ds"]/60, trace["dFF_ds_sm"], color = "black", linewidth = 2, label = "dFF_ds_sm")
        if min(trace["dFF_ds_sm"]) > 0:
            ax[5].set_ylim(0.95*min(trace["dFF_ds_sm"]), 1.05*max(trace["dFF_ds_sm"]))
        else:
            ax[5].set_ylim(1.05*min(trace["dFF_ds_sm"]), 1.05*max(trace["dFF_ds_sm"]))
        ax[5].set_ylabel("dF/F0 (%)")
        ax[5].set_xlabel("time (min)")
        ax[5].legend(loc='upper right', fontsize = 16)
        
        suptitle = trace["mouseID"] +"_"+ trace["date"] +"_"+ trace["stimulus"]
        plt.suptitle("%s" %suptitle) 
        plt.tight_layout(rect=[0, 0.03, 1, 0.95])    
      
        if ignore_UV == 0 :  # if using the UV channel (most common way)
            save_file_path = analysis_path + "/" + suptitle + ".png"
            plt.savefig(save_file_path)
            save_file_path = analysis_path + "/" + suptitle + ".pdf"
            plt.savefig(save_file_path)
            plt.show()
            
        else:               # if NOT using the UV channel 
            save_file_path = analysis_path + "/" + suptitle + "_wUV.png"
            plt.savefig(save_file_path)
            save_file_path = analysis_path + "/" + suptitle + "_wUV.pdf"
            plt.savefig(save_file_path)
            plt.show()

            # Redefine F0 and dFF only based on GCaMP channel and save this as dFF 
    
            F0                   = np.median(trace["GCaMP"][F0_window_start_frame:F0_window_end_frame])
           
            trace["dFF"]         = (trace["GCaMP"] - F0)/F0*100 
            trace["frame"]       = np.arange(0, len(trace["GCaMP"]), 1)
            trace["dFF_sm"]      = smooth(trace["dFF"], window_len = sm_factor)
            trace["dFF_sm_peak"] = np.max(trace["dFF_sm"])
            trace["dFF_sm_scaled"]  = trace["dFF_sm"]/trace["dFF_sm_peak"]


            ##  3) plot dFF with all dictionary keys      
            fig, ax = plt.subplots(3,1, figsize = (8, 8))
            ax[0].plot(trace["time_sec"]/60, trace["GCaMP"], color = "green", linewidth = 2, label = "GCaMP")
            ax[0].set_ylim(0.95*min(trace["GCaMP"]), 1.05*max(trace["GCaMP"]))
            ax[0].set_ylabel("raw (a.u.)")
            ax[0].legend(loc='upper right', fontsize = 16)
 
            ax[1].plot(trace["time_sec"]/60, trace["dFF"], color = "blue", linewidth = 2, label = "dFF")
            if min(trace["dFF"]) > 0:
                ax[1].set_ylim(0.95*min(trace["dFF"]), 1.05*max(trace["dFF"]))
            else: 
                ax[1].set_ylim(1.05*min(trace["dFF"]), 1.05*max(trace["dFF"]))
            ax[1].set_ylabel("dF/F0 (%)")  
            ax[1].legend(loc='upper right', fontsize = 16)
              
            ax[2].plot(trace["time_sec"]/60, trace["dFF_sm"], color = "navy", linewidth = 2, label = "dFF_smooth")
            if min(trace["dFF_sm"]) > 0:
                ax[2].set_ylim(0.95*min(trace["dFF_sm"]), 1.05*max(trace["dFF_sm"]))
            else: 
                ax[2].set_ylim(1.05*min(trace["dFF_sm"]), 1.05*max(trace["dFF_sm"]))
            ax[2].set_ylabel("dF/F0 (%)") 
            ax[2].set_xlabel("time (min)")
            ax[2].legend(loc='upper right', fontsize = 16)
            
            suptitle = trace["mouseID"] +"_"+ trace["date"] +"_"+ trace["stimulus"]
            plt.suptitle("%s" %suptitle) 
            plt.tight_layout(rect=[0, 0.03, 1, 0.95])    
    
            save_file_path = analysis_path + "/" + suptitle + "_noUV.png"
            plt.savefig(save_file_path)
            save_file_path = analysis_path + "/" + suptitle + "_noUV.pdf"
            plt.savefig(save_file_path)
            plt.show()      
            
        save_file_path  = analysis_path + "/" + suptitle + ".pkl"
        output = open(save_file_path, 'wb')
        pk.dump(trace, output)
        output.close()   
        
        
# ##################################################
# #   POP open the analysis folder
# ##################################################
os.startfile(analysis_path)
